/*
 * This Scala source file was generated by the Gradle 'init' task.
 */
package taller
import org.scalameter.{withWarmer, _}

object App {
    def main(args: Array[String]): Unit = {
        /*
        //MULTIPLICAR MATRICES SECUENCIAL
        val time = config (
                    KeyValue(Key.exec.minWarmupRuns -> 20),
                    KeyValue(Key.exec.maxWarmupRuns -> 60),
                    KeyValue(Key.verbose -> true)
                )withWarmer(new Warmer.Default) measure {
                    val multiplicar = new MultiplicarMatrices
                    val m1 = multiplicar.matrizAlAzar(25, 25)
                    val m2 = multiplicar.matrizAlAzar(25, 25)
                    println("Matriz Resultante: " , multiplicar.multMatriz(m1, m2))
                }
                println(time)
        //MULTIPLICAR MATRICES PARALELA
        val time = config (
                    KeyValue(Key.exec.minWarmupRuns -> 20),
                    KeyValue(Key.exec.maxWarmupRuns -> 60),
                    KeyValue(Key.verbose -> true)
                )withWarmer(new Warmer.Default) measure {
                    val multiplicarParalelas = new MultiplicarMatricesParalelas
                    val m1p = multiplicarParalelas.matrizAlAzar(25, 25)
                    val m2p = multiplicarParalelas.matrizAlAzar(25, 25)
                    println("Matriz Resultante: " , multiplicarParalelas.multMatriz(m1p, m2p))
                }
                println(time)
        //MULTIPLICAR MATRICES RECURSIVA SECUENCIAL
        val time = config (
                    KeyValue(Key.exec.minWarmupRuns -> 20),
                    KeyValue(Key.exec.maxWarmupRuns -> 60),
                    KeyValue(Key.verbose -> true)
                )withWarmer(new Warmer.Default) measure {
                    val multiplicarMatricesRec = new MultiplicarMatricesRec
                    val matriz1 = multiplicarMatricesRec.matrizAlAzar(25, 10) // Matriz 2x2 con valores aleatorios
                    val matriz2 = multiplicarMatricesRec.matrizAlAzar(25, 10) // Otra matriz 2x2
                    val resultadoRecursivo = multiplicarMatricesRec.multMatrizRec(matriz1, matriz2)

                    println("\nResultado de la multiplicación recursiva:")
                    resultadoRecursivo.foreach(println)
                }
                println(time)
        //MULTIPLICAR MATRICES STRASSEN SECUENCIAL
        val time = config (
                    KeyValue(Key.exec.minWarmupRuns -> 20),
                    KeyValue(Key.exec.maxWarmupRuns -> 60),
                    KeyValue(Key.verbose -> true)
                )withWarmer(new Warmer.Default) measure {
                    val size = 16// Tamaño de la matriz (debe ser potencia de 2)
                    val maxValue = 10
                    val strassen = new MultiplicarMatricesStrassen()
                    val matriz1 = strassen.matrizAlAzar(size, maxValue)
                    val matriz2 = strassen.matrizAlAzar(size, maxValue)
                    val resultado = strassen.strassenMetodo(matriz1, matriz2)
                    println("\nResultado:")
                    resultado.foreach(row => println(row.mkString(" ")))
                }
                println(time)
        //MULTIPLICAR MATRICES STRASSEN PARALELO
        val time = config (
                    KeyValue(Key.exec.minWarmupRuns -> 20),
                    KeyValue(Key.exec.maxWarmupRuns -> 60),
                    KeyValue(Key.verbose -> true)
                )withWarmer(new Warmer.Default) measure {
                    val size = 2 // Tamaño de la matriz (debe ser potencia de 2)
                    val maxValue = 10
                    val strassenParalelo = new MultiplicarMatricesStrassenParalelo()
                    val matriz1 = strassenParalelo.matrizAlAzar(size, maxValue)
                    val matriz2 = strassenParalelo.matrizAlAzar(size, maxValue)
                    val resultado = strassenParalelo.strassenParalelo(matriz1, matriz2)
                    resultado.foreach(row => println(row.mkString(" ")))
                }
                println(time)
        //PRODUCTO PUNTO VECTORES SECUENCIAL
        val time = config (
                    KeyValue(Key.exec.minWarmupRuns -> 20),
                    KeyValue(Key.exec.maxWarmupRuns -> 60),
                    KeyValue(Key.verbose -> true)
                )withWarmer(new Warmer.Default) measure {
                    val clase = new ProductoPuntoVectores()
                    val vector1 = clase.vectorAlAzar(15, 10) // Vector de 5 elementos con valores entre 0 y 9
                    val vector2 = clase.vectorAlAzar(15, 10) // Otro vector de 5 elementos
                    val resultadoSecuencial = clase.productoPuntoSecuencial(vector1, vector2)
                    println(s"Producto punto secuencial: $resultadoSecuencial")

                }
                println(time)
        //PRODUCTO PUNTO VECTORES PARALELO
        val time = config (
                    KeyValue(Key.exec.minWarmupRuns -> 20),
                    KeyValue(Key.exec.maxWarmupRuns -> 60),
                    KeyValue(Key.verbose -> true)
                )withWarmer(new Warmer.Default) measure {
                    val clase = new ProductoPuntoVectores()
                    val vector1 = clase.vectorAlAzar(15, 10) // Vector de 5 elementos con valores entre 0 y 9
                    val vector2 = clase.vectorAlAzar(15, 10) // Otro vector de 5 elementos
                    val resultadoParalelo = clase.productoPuntoParalelo(vector1, vector2)
                    println(s"Producto punto paralelo: $resultadoParalelo")

                }
                println(time)
        */
    }
}
